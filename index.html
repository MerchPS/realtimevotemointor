<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Vote Comparator ‚Äî All Submissions</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#07121b; --card:#0b1622; --muted:#98a6b8; --ycol:#6bc1ff; --wcol:#ff6b6b;
    --glass: rgba(255,255,255,0.03);
  }
  *{box-sizing:border-box;font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;}
  body{margin:0;background:linear-gradient(180deg,#051022 0%, #071735 100%);color:#e6eef8;min-height:100vh;padding:22px;}
  .container{max-width:1100px;margin:0 auto;}
  header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:18px}
  h1{margin:0;font-size:20px}
  p.lead{margin:4px 0 0;color:var(--muted);font-size:13px}
  .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.04);padding:12px;border-radius:10px;box-shadow:0 8px 30px rgba(2,6,23,0.6)}
  .big{font-size:28px;font-weight:700}
  .small{color:var(--muted);font-size:12px}
  .delta-up{color:#6ee7b7;font-weight:700}
  .delta-down{color:#ff8b8b;font-weight:700}
  .chart-wrap{background:var(--card);padding:12px;border-radius:10px;margin-bottom:12px}
  canvas{max-width:100%}
  .summary{display:flex;gap:12px;flex-wrap:wrap}
  .stat{background:var(--glass);padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);min-width:160px}
  .muted{color:var(--muted)}
  footer{margin-top:14px;color:var(--muted);font-size:13px}
  .log{height:120px;overflow:auto;background:rgba(0,0,0,0.2);padding:8px;border-radius:8px;font-size:12px;color:#d9e9ff}
  
  /* New styles for all submissions */
  .submissions-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 12px;
    margin-bottom: 12px;
  }
  .submission-card {
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border: 1px solid rgba(255,255,255,0.04);
    padding: 12px;
    border-radius: 10px;
    box-shadow: 0 8px 30px rgba(2,6,23,0.6);
    transition: all 0.3s ease;
  }
  .submission-card.loading {
    opacity: 0.6;
    border-color: rgba(255,255,255,0.1);
  }
  .submission-card.error {
    border-color: #ff6b6b;
  }
  .submission-card h3 {
    margin: 0 0 6px;
    font-size: 14px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .submission-stats {
    display: flex;
    align-items: center;
    justify-content: space-between;
  }
  .submission-votes {
    font-size: 20px;
    font-weight: 700;
  }
  .submission-delta {
    text-align: right;
  }
  
  /* Progress bar */
  .progress-container {
    width: 100%;
    height: 4px;
    background: rgba(255,255,255,0.1);
    border-radius: 2px;
    margin-bottom: 8px;
    overflow: hidden;
  }
  .progress-bar {
    height: 100%;
    background: linear-gradient(90deg, #6bc1ff, #6ee7b7);
    border-radius: 2px;
    transition: width 0.3s ease;
  }
  
  /* Control buttons */
  .controls {
    display: flex;
    gap: 8px;
    margin-bottom: 12px;
  }
  .btn {
    background: rgba(255,255,255,0.05);
    border: 1px solid rgba(255,255,255,0.1);
    color: #e6eef8;
    padding: 6px 12px;
    border-radius: 6px;
    font-size: 12px;
    cursor: pointer;
    transition: all 0.2s ease;
  }
  .btn:hover {
    background: rgba(255,255,255,0.1);
  }
  .btn:active {
    transform: scale(0.98);
  }
  
  @media (max-width: 860px) { 
    .submissions-grid { grid-template-columns: repeat(2, 1fr); }
  }
  @media (max-width: 480px) { 
    .submissions-grid { grid-template-columns: 1fr; }
  }
</style>
</head>
<body>
  <div class="container">
    <header>
      <div>
        <h1>Vote Comparator ‚Äî All Submissions</h1>
        <p class="lead">Realtime tracking for all 8 submissions. Auto-update every <strong>3s</strong>.</p>
      </div>
      <div style="text-align:right">
        <div style="font-size:12px;color:var(--muted)">Status:</div>
        <div id="status" class="small muted">Initializing‚Ä¶</div>
      </div>
    </header>

    <!-- Controls -->
    <div class="controls">
      <button id="refreshBtn" class="btn">üîÑ Refresh Now</button>
      <button id="testProxyBtn" class="btn">üß™ Test Proxies</button>
      <button id="toggleAutoBtn" class="btn">‚è∏Ô∏è Pause Auto</button>
    </div>

    <!-- Progress Bar -->
    <div class="progress-container">
      <div id="progressBar" class="progress-bar" style="width: 0%"></div>
    </div>

    <!-- All Submissions Grid -->
    <div class="submissions-grid" id="submissionsGrid">
      <!-- Will be populated by JavaScript -->
    </div>

    <div class="chart-wrap card">
      <canvas id="votesChart" height="140"></canvas>
    </div>

    <div class="card summary">
      <div class="stat">
        <div class="small muted">Current Leader</div>
        <div id="leadText" style="font-weight:700;font-size:16px">‚Äî</div>
      </div>
      <div class="stat">
        <div class="small muted">Total Œî (this session)</div>
        <div id="sessionDelta" style="font-weight:700;font-size:16px">Loading...</div>
      </div>
      <div class="stat">
        <div class="small muted">Last update</div>
        <div id="lastUpdate" style="font-weight:700;font-size:14px">‚Äî</div>
      </div>
      <div class="stat">
        <div class="small muted">Working Proxies</div>
        <div id="proxyStatus" style="font-weight:700;font-size:14px">0/0</div>
      </div>
    </div>

    <div style="margin-top:12px" class="card">
      <div class="small muted">Console log</div>
      <div id="console" class="log"></div>
    </div>

    <footer>
      <div class="small muted">Using multiple fallback strategies. If all proxies fail, try refreshing or wait for auto-recovery.</div>
    </footer>
  </div>

  <!-- Chart.js CDN -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
  (function(){
    // CONFIG
    const INTERVAL_MS = 3000; // 3s
    const CONCURRENT_REQUESTS = 3; // Reduced concurrency to avoid blocking
    
    // All 8 submissions
    const SUBMISSIONS = [
      { id: "24087", name: "xxknjt" },
      { id: "24084", name: "ini boo" },
      { id: "24081", name: "JustDani" },
      { id: "24078", name: "SonMV" },
      { id: "24075", name: "KekeLawar" },
      { id: "24072", name: "Yaraayay" },
      { id: "24069", name: "Wasawho" },
      { id: "24066", name: "searchforemma" }
    ];
    
    const URL_TEMPLATE = (id) => `https://motionimefest.id/contest/newcomer-streamer-of-the-year/submission/${id}/?cid=23816&cm=1`;

    // Enhanced CORS proxies list with more options
    const PROXY_LIST = [
      // Primary proxies (most reliable)
      { name: 'AllOrigins', url: url => `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}` },
      { name: 'CorsProxy', url: url => `https://corsproxy.io/?${encodeURIComponent(url)}` },
      { name: 'CodeTabs', url: url => `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(url)}` },
      
      // Secondary proxies
      { name: 'ProxyKing', url: url => `https://proxy.kingthetoto.workers.dev/?${encodeURIComponent(url)}` },
      { name: 'CorsAnywhere', url: url => `https://cors-anywhere.herokuapp.com/${url}` },
      { name: 'ThingsProxy', url: url => `https://thingproxy.freeboard.io/fetch/${url}` },
      
      // Backup proxies
      { name: 'CorsContainer', url: url => `https://api.cors.workers.dev/?${encodeURIComponent(url)}` },
      { name: 'AllOrigins2', url: url => `https://api.allorigins.win/get?url=${encodeURIComponent(url)}` }
    ];

    // DOM
    const statusEl = document.getElementById('status');
    const logEl = document.getElementById('console');
    const submissionsGridEl = document.getElementById('submissionsGrid');
    const leadTextEl = document.getElementById('leadText');
    const sessionDeltaEl = document.getElementById('sessionDelta');
    const lastUpdateEl = document.getElementById('lastUpdate');
    const proxyStatusEl = document.getElementById('proxyStatus');
    const progressBarEl = document.getElementById('progressBar');
    const refreshBtn = document.getElementById('refreshBtn');
    const testProxyBtn = document.getElementById('testProxyBtn');
    const toggleAutoBtn = document.getElementById('toggleAutoBtn');

    // state
    let lastVotes = {};
    let lastTime = null;
    let sessionDelta = {};
    let historyLabels = [];
    let historyData = {};
    let workingProxies = [];
    let isAutoUpdate = true;
    let updateInterval;
    let proxyTestResults = {};

    // Initialize state
    SUBMISSIONS.forEach(sub => {
      lastVotes[sub.id] = null;
      sessionDelta[sub.id] = 0;
      historyData[sub.id] = [];
    });

    // helper: log (console area)
    function clog(msg){
      const ts = new Date().toLocaleTimeString();
      logEl.innerText = `[${ts}] ${msg}\n` + logEl.innerText;
      // Keep log from getting too long
      if(logEl.innerText.split('\n').length > 50) {
        logEl.innerText = logEl.innerText.split('\n').slice(0, 40).join('\n');
      }
    }

    // helper: parse numbers like "3,768" or "90.123"
    function parseNumber(s){
      if(!s) return null;
      const clean = s.replace(/,/g, '');
      const digits = clean.replace(/[^\d]/g, '');
      return digits ? parseInt(digits,10) : null;
    }

    // Improved parsing function with multiple strategies
    function extractVotesViews(html){
      try {
        if (!html || html.length < 100) {
          return {votes: null, views: null};
        }

        const tmp = document.createElement('div');
        tmp.innerHTML = html;
        const text = tmp.textContent || tmp.innerText || '';
        
        // Strategy 1: Direct text patterns
        const votePatterns = [
          /([\d,]+)\s*Votes?/i,
          /Votes?\s*([\d,]+)/i,
          /"votes?"\s*:\s*"([\d,]+)"/i,
          /vote_count["']?\s*:\s*["']?([\d,]+)/i,
          /class=".*votes?.*">\s*([\d,]+)/i
        ];
        
        const viewPatterns = [
          /([\d,]+)\s*Views?/i,
          /Views?\s*([\d,]+)/i,
          /"views?"\s*:\s*"([\d,]+)"/i,
          /view_count["']?\s*:\s*["']?([\d,]+)/i,
          /class=".*views?.*">\s*([\d,]+)/i
        ];
        
        let votes = null, views = null;
        
        // Try each vote pattern
        for(const pattern of votePatterns) {
          const match = text.match(pattern);
          if(match) {
            votes = parseNumber(match[1]);
            if(votes !== null) break;
          }
        }
        
        // Try each view pattern
        for(const pattern of viewPatterns) {
          const match = text.match(pattern);
          if(match) {
            views = parseNumber(match[1]);
            if(views !== null) break;
          }
        }
        
        // Strategy 2: Look for common HTML structures
        if (votes === null) {
          const voteElements = tmp.querySelectorAll('[class*="vote"], [id*="vote"]');
          for(const el of voteElements) {
            const elText = el.textContent || '';
            const numMatch = elText.match(/([\d,]+)/);
            if(numMatch && elText.toLowerCase().includes('vote')) {
              votes = parseNumber(numMatch[1]);
              if(votes !== null) break;
            }
          }
        }
        
        return {votes, views};
      } catch(e) {
        clog(`Error parsing HTML: ${e.message}`);
        return {votes: null, views: null};
      }
    }

    // Test if a proxy is working
    async function testProxy(proxy, testUrl) {
      try {
        const proxyUrl = proxy.url(testUrl);
        const controller = new AbortController();
        const timeoutId = setTimeout(() => controller.abort(), 5000);
        
        const response = await fetch(proxyUrl, {
          method: 'GET',
          signal: controller.signal,
          headers: {
            'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
          }
        });
        
        clearTimeout(timeoutId);
        
        if(response.ok) {
          const text = await response.text();
          if(text && text.length > 100) {
            return { working: true, response: text.substring(0, 200) + '...' };
          }
        }
        return { working: false, error: `Status: ${response.status}` };
      } catch(error) {
        return { working: false, error: error.message };
      }
    }

    // Test all proxies
    async function testAllProxies() {
      clog("üß™ Testing all proxies...");
      const testUrl = URL_TEMPLATE("24072"); // Test with one submission
      workingProxies = [];
      
      for(const proxy of PROXY_LIST) {
        statusEl.innerText = `Testing ${proxy.name}...`;
        const result = await testProxy(proxy, testUrl);
        proxyTestResults[proxy.name] = result;
        
        if(result.working) {
          workingProxies.push(proxy);
          clog(`‚úÖ ${proxy.name}: WORKING`);
        } else {
          clog(`‚ùå ${proxy.name}: ${result.error}`);
        }
        
        // Small delay between tests
        await new Promise(resolve => setTimeout(resolve, 500));
      }
      
      proxyStatusEl.textContent = `${workingProxies.length}/${PROXY_LIST.length}`;
      clog(`Proxy test completed: ${workingProxies.length} working`);
      statusEl.innerText = `Ready - ${workingProxies.length} proxies working`;
      
      return workingProxies.length > 0;
    }

    // Enhanced fetch with multiple fallback strategies
    async function fetchWithFallback(url, attempt = 0) {
      const maxAttempts = 3;
      
      // Strategy 1: Try direct fetch (no-cors mode)
      if(attempt === 0) {
        try {
          const response = await fetch(url, {
            method: 'GET',
            mode: 'no-cors', // Try no-cors first
            cache: 'no-cache'
          });
          // With no-cors we can't read response, but it might trigger the page load
          clog("Direct no-cors request sent");
          // Continue to proxy strategy
        } catch(e) {
          // Expected to fail in no-cors, continue to proxies
        }
      }
      
      // Strategy 2: Try working proxies
      if(workingProxies.length > 0) {
        const proxyIndex = attempt % workingProxies.length;
        const proxy = workingProxies[proxyIndex];
        
        try {
          const proxyUrl = proxy.url(url);
          const controller = new AbortController();
          const timeoutId = setTimeout(() => controller.abort(), 8000);
          
          const response = await fetch(proxyUrl, {
            method: 'GET',
            signal: controller.signal,
            headers: {
              'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            }
          });
          
          clearTimeout(timeoutId);
          
          if(response.ok) {
            const text = await response.text();
            if(text && text.length > 100) {
              return {
                html: text,
                usedProxy: true,
                proxyName: proxy.name,
                success: true
              };
            }
          }
        } catch(error) {
          clog(`Proxy ${proxy.name} failed: ${error.message}`);
        }
      }
      
      // Strategy 3: Try all proxies as fallback
      if(attempt < maxAttempts) {
        for(const proxy of PROXY_LIST) {
          if(workingProxies.includes(proxy)) continue; // Skip already tried
          
          try {
            const proxyUrl = proxy.url(url);
            const response = await fetch(proxyUrl, {
              method: 'GET',
              headers: {
                'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
              }
            });
            
            if(response.ok) {
              const text = await response.text();
              if(text && text.length > 100) {
                workingProxies.push(proxy); // Add to working list
                return {
                  html: text,
                  usedProxy: true,
                  proxyName: proxy.name,
                  success: true
                };
              }
            }
          } catch(error) {
            // Continue to next proxy
          }
        }
        
        // Retry with next attempt
        return fetchWithFallback(url, attempt + 1);
      }
      
      throw new Error(`All fetch strategies failed after ${maxAttempts} attempts`);
    }

    // Parallel fetching with concurrency control
    async function fetchAllSubmissionsParallel() {
      const results = {};
      let completed = 0;
      const total = SUBMISSIONS.length;
      
      // Update progress bar
      progressBarEl.style.width = '0%';
      
      // Function to process a batch of submissions
      const processBatch = async (batch) => {
        const batchPromises = batch.map(async (sub) => {
          try {
            // Set loading state
            const cardEl = document.getElementById(`card-${sub.id}`);
            if(cardEl) {
              cardEl.classList.add('loading');
              cardEl.classList.remove('error');
            }
            
            const result = await fetchWithFallback(URL_TEMPLATE(sub.id));
            const extracted = extractVotesViews(result.html);
            
            results[sub.id] = extracted;
            
            // Remove loading state
            if(cardEl) {
              cardEl.classList.remove('loading');
              if(extracted.votes === null) {
                cardEl.classList.add('error');
              }
            }
            
            if(extracted.votes !== null) {
              clog(`‚úÖ ${sub.name}: ${extracted.votes} votes (via ${result.proxyName || 'direct'})`);
            } else {
              clog(`‚ùå ${sub.name}: No data found in response`);
            }
          } catch(e) {
            clog(`‚ùå ${sub.name}: ${e.message}`);
            results[sub.id] = {votes: null, views: null};
            
            // Set error state
            const cardEl = document.getElementById(`card-${sub.id}`);
            if(cardEl) {
              cardEl.classList.remove('loading');
              cardEl.classList.add('error');
            }
          }
          
          // Update progress
          completed++;
          const progress = (completed / total) * 100;
          progressBarEl.style.width = `${progress}%`;
          
          // Update status
          statusEl.innerText = `Fetching... ${completed}/${total} (${workingProxies.length} proxies)`;
        });
        
        return Promise.allSettled(batchPromises);
      };
      
      // Split submissions into batches
      const batches = [];
      for(let i = 0; i < SUBMISSIONS.length; i += CONCURRENT_REQUESTS) {
        batches.push(SUBMISSIONS.slice(i, i + CONCURRENT_REQUESTS));
      }
      
      // Process batches sequentially but each batch in parallel
      for(const batch of batches) {
        await processBatch(batch);
        // Small delay between batches to avoid overwhelming
        await new Promise(resolve => setTimeout(resolve, 300));
      }
      
      return {results, successCount: Object.values(results).filter(r => r.votes !== null).length};
    }

    // Create submission cards
    function createSubmissionCards() {
      submissionsGridEl.innerHTML = '';
      SUBMISSIONS.forEach(sub => {
        const card = document.createElement('div');
        card.className = 'submission-card';
        card.id = `card-${sub.id}`;
        card.innerHTML = `
          <h3>${sub.name} ‚Äî ${sub.id}</h3>
          <div class="submission-stats">
            <div>
              <div id="votes-${sub.id}" class="submission-votes">‚Äî</div>
              <div id="views-${sub.id}" class="small muted">‚Äî views</div>
            </div>
            <div class="submission-delta">
              <div class="small muted">Œî per 3s</div>
              <div id="delta-${sub.id}" class="small">‚Äî</div>
              <div class="small muted" style="margin-top:6px">Rate (v/s)</div>
              <div id="rate-${sub.id}" class="small">‚Äî</div>
            </div>
          </div>
        `;
        submissionsGridEl.appendChild(card);
      });
    }

    // UI update function
    function updateUI(data){
      let activeCount = 0;
      
      // Update individual submission cards
      SUBMISSIONS.forEach(sub => {
        const votesEl = document.getElementById(`votes-${sub.id}`);
        const viewsEl = document.getElementById(`views-${sub.id}`);
        const deltaEl = document.getElementById(`delta-${sub.id}`);
        const rateEl = document.getElementById(`rate-${sub.id}`);
        const cardEl = document.getElementById(`card-${sub.id}`);
        
        const subData = data[sub.id];
        if (subData && subData.votes !== null) {
          activeCount++;
          votesEl.innerText = subData.votes.toLocaleString();
          viewsEl.innerText = subData.views !== null ? (subData.views.toLocaleString() + ' views') : '‚Äî views';
          deltaEl.innerText = (subData.delta >= 0 ? '+' + subData.delta : subData.delta);
          deltaEl.className = subData.delta > 0 ? 'small delta-up' : (subData.delta < 0 ? 'small delta-down' : 'small');
          rateEl.innerText = subData.rate !== null ? subData.rate.toFixed(4) : '‚Äî';
          cardEl.style.opacity = '1';
          cardEl.classList.remove('error');
        } else {
          votesEl.innerText = '‚Äî';
          viewsEl.innerText = '‚Äî views';
          deltaEl.innerText = '‚Äî';
          rateEl.innerText = '‚Äî';
          cardEl.style.opacity = '0.7';
        }
      });

      // Update session delta
      let sessionText = "";
      SUBMISSIONS.forEach(sub => {
        if (sessionDelta[sub.id] !== 0) {
          if (sessionText) sessionText += " | ";
          sessionText += `${sub.name}: ${sessionDelta[sub.id] > 0 ? '+' : ''}${sessionDelta[sub.id]}`;
        }
      });
      sessionDeltaEl.innerText = sessionText || "No changes yet";

      // Update leader
      const validData = SUBMISSIONS.filter(sub => 
        data[sub.id] && data[sub.id].votes !== null
      );
      
      if (validData.length > 0) {
        const leader = validData.reduce((prev, curr) => 
          data[prev.id].votes > data[curr.id].votes ? prev : curr
        );
        const leaderVotes = data[leader.id].votes;
        
        // Check for ties
        const tied = validData.filter(sub => 
          data[sub.id].votes === leaderVotes
        );
        
        if (tied.length > 1) {
          leadTextEl.innerHTML = `Tie: ${tied.map(t => t.name).join(', ')} with ${leaderVotes.toLocaleString()} votes`;
        } else {
          leadTextEl.innerHTML = `${leader.name} leading with <strong>${leaderVotes.toLocaleString()}</strong> votes`;
        }
      } else {
        leadTextEl.innerText = 'No data available';
      }

      lastUpdateEl.innerText = new Date().toLocaleTimeString();
      proxyStatusEl.textContent = `${workingProxies.length}/${PROXY_LIST.length}`;
    }

    // Chart.js setup
    const ctx = document.getElementById('votesChart').getContext('2d');
    
    // Generate colors for all submissions
    const colors = [
      '#6bc1ff', '#ff6b6b', '#6ee7b7', '#f59e0b', '#a78bfa', 
      '#f97316', '#10b981', '#8b5cf6'
    ];
    
    const chartDatasets = SUBMISSIONS.map((sub, index) => ({
      label: `${sub.name}`,
      data: historyData[sub.id],
      borderColor: colors[index % colors.length],
      backgroundColor: colors[index % colors.length] + '20',
      tension: 0.2,
      pointRadius: 2,
      borderWidth: 2,
      hidden: false
    }));
    
    const chart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: historyLabels,
        datasets: chartDatasets
      },
      options: {
        animation: false,
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          x: { 
            display: true, 
            title: { display: false },
            ticks: {
              maxTicksLimit: 8
            }
          },
          y: { 
            display: true, 
            beginAtZero: false, 
            title: { display: true, text: 'Votes' } 
          }
        },
        plugins: { 
          legend: { 
            display: true,
            labels: {
              boxWidth: 12,
              font: {
                size: 11
              }
            }
          } 
        }
      }
    });

    // main polling function
    async function pollOnce(){
      const startTime = performance.now();
      
      try {
        // Re-test proxies if none are working
        if(workingProxies.length === 0) {
          clog("No working proxies, testing all proxies...");
          await testAllProxies();
        }
        
        // Fetch all submissions in parallel
        const {results, successCount} = await fetchAllSubscriptionsParallel();
        
        const now = Date.now();
        const data = {};
        
        // Process results
        SUBMISSIONS.forEach(sub => {
          const extracted = results[sub.id];
          
          // Compute deltas
          let delta = 0, rate = null;
          if(lastTime !== null && lastVotes[sub.id] !== null && extracted.votes !== null){
            const elapsedSec = (now - lastTime)/1000;
            delta = extracted.votes - lastVotes[sub.id];
            rate = delta/elapsedSec;
          }
          
          // Update session totals
          if(delta) sessionDelta[sub.id] += delta;
          
          // Store data
          data[sub.id] = {
            votes: extracted.votes,
            views: extracted.views,
            delta: delta,
            rate: rate
          };
          
          // Update last votes
          lastVotes[sub.id] = extracted.votes;
        });
        
        // Push history
        const label = new Date().toLocaleTimeString();
        historyLabels.push(label);
        
        SUBMISSIONS.forEach(sub => {
          historyData[sub.id].push(data[sub.id].votes ?? null);
        });
        
        // Keep history limited
        if(historyLabels.length > 50){ 
          historyLabels.shift(); 
          SUBMISSIONS.forEach(sub => {
            historyData[sub.id].shift();
          });
        }

        // Update chart
        chart.data.labels = historyLabels.slice();
        SUBMISSIONS.forEach((sub, index) => {
          chart.data.datasets[index].data = historyData[sub.id].slice();
        });
        chart.update('none');

        // Update UI elements
        updateUI(data);

        // Update last time
        lastTime = now;

        const elapsedMs = Math.round(performance.now() - startTime);
        statusEl.innerText = `OK - ${successCount}/8 submissions - ${elapsedMs}ms`;
        
        clog(`‚úÖ Completed in ${elapsedMs}ms - ${successCount}/8 successful`);
        
      } catch(err) {
        statusEl.innerText = 'Error: ' + err.message;
        clog('‚ùå Error in poll: ' + err.message);
        
        // If major error, re-test proxies
        workingProxies = [];
      }
    }

    // Event listeners
    refreshBtn.addEventListener('click', () => {
      clog("Manual refresh triggered");
      pollOnce();
    });

    testProxyBtn.addEventListener('click', async () => {
      await testAllProxies();
    });

    toggleAutoBtn.addEventListener('click', () => {
      isAutoUpdate = !isAutoUpdate;
      if(isAutoUpdate) {
        clearInterval(updateInterval);
        updateInterval = setInterval(pollOnce, INTERVAL_MS);
        toggleAutoBtn.textContent = '‚è∏Ô∏è Pause Auto';
        clog("Auto-update resumed");
      } else {
        clearInterval(updateInterval);
        toggleAutoBtn.textContent = '‚ñ∂Ô∏è Resume Auto';
        clog("Auto-update paused");
      }
    });

    // Initialize application
    async function initializeApp() {
      createSubmissionCards();
      clog("üöÄ Vote Comparator starting...");
      
      // Test proxies first
      await testAllProxies();
      
      // First poll
      await pollOnce();
      
      // Start auto-update
      updateInterval = setInterval(pollOnce, INTERVAL_MS);
      clog(`Auto-update started (${INTERVAL_MS}ms interval)`);
    }

    // Start the application
    initializeApp();

  })();
  </script>
</body>
</html>
