<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>Vote Comparator — All Submissions</title>
<link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
<style>
  :root{
    --bg:#07121b; --card:#0b1622; --muted:#98a6b8; --ycol:#6bc1ff; --wcol:#ff6b6b;
    --glass: rgba(255,255,255,0.03);
  }
  *{box-sizing:border-box;font-family:Inter,system-ui,-apple-system,"Segoe UI",Roboto,"Helvetica Neue",Arial;}
  body{margin:0;background:linear-gradient(180deg,#051022 0%, #071735 100%);color:#e6eef8;min-height:100vh;padding:22px;}
  .container{max-width:1100px;margin:0 auto;}
  header{display:flex;align-items:center;justify-content:space-between;gap:12px;margin-bottom:18px}
  h1{margin:0;font-size:20px}
  p.lead{margin:4px 0 0;color:var(--muted);font-size:13px}
  .card{background:linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));border:1px solid rgba(255,255,255,0.04);padding:12px;border-radius:10px;box-shadow:0 8px 30px rgba(2,6,23,0.6)}
  .big{font-size:28px;font-weight:700}
  .small{color:var(--muted);font-size:12px}
  .delta-up{color:#6ee7b7;font-weight:700}
  .delta-down{color:#ff8b8b;font-weight:700}
  .chart-wrap{background:var(--card);padding:12px;border-radius:10px;margin-bottom:12px}
  canvas{max-width:100%}
  .summary{display:flex;gap:12px;flex-wrap:wrap}
  .stat{background:var(--glass);padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.03);min-width:160px}
  .muted{color:var(--muted)}
  footer{margin-top:14px;color:var(--muted);font-size:13px}
  .log{height:120px;overflow:auto;background:rgba(0,0,0,0.2);padding:8px;border-radius:8px;font-size:12px;color:#d9e9ff}
  
  /* New styles for all submissions */
  .submissions-grid {
    display: grid;
    grid-template-columns: repeat(4, 1fr);
    gap: 12px;
    margin-bottom: 12px;
  }
  .submission-card {
    background: linear-gradient(180deg, rgba(255,255,255,0.02), rgba(255,255,255,0.01));
    border: 1px solid rgba(255,255,255,0.04);
    padding: 12px;
    border-radius: 10px;
    box-shadow: 0 8px 30px rgba(2,6,23,0.6);
    transition: all 0.3s ease;
  }
  .submission-card.loading {
    opacity: 0.6;
    border-color: rgba(255,255,255,0.1);
  }
  .submission-card h3 {
    margin: 0 0 6px;
    font-size: 14px;
    white-space: nowrap;
    overflow: hidden;
    text-overflow: ellipsis;
  }
  .submission-stats {
    display: flex;
    align-items: center;
    justify-content: space-between;
  }
  .submission-votes {
    font-size: 20px;
    font-weight: 700;
  }
  .submission-delta {
    text-align: right;
  }
  
  /* Progress bar */
  .progress-container {
    width: 100%;
    height: 4px;
    background: rgba(255,255,255,0.1);
    border-radius: 2px;
    margin-bottom: 8px;
    overflow: hidden;
  }
  .progress-bar {
    height: 100%;
    background: linear-gradient(90deg, #6bc1ff, #6ee7b7);
    border-radius: 2px;
    transition: width 0.3s ease;
  }
  
  @media (max-width: 860px) { 
    .submissions-grid { grid-template-columns: repeat(2, 1fr); }
  }
  @media (max-width: 480px) { 
    .submissions-grid { grid-template-columns: 1fr; }
  }
</style>
</head>
<body>
  <div class="container">
    <header>
      <div>
        <h1>Vote Comparator — All Submissions</h1>
        <p class="lead">Realtime tracking for all 8 submissions. Auto-update every <strong>2.5s</strong>.</p>
      </div>
      <div style="text-align:right">
        <div style="font-size:12px;color:var(--muted)">Status:</div>
        <div id="status" class="small muted">Initializing…</div>
      </div>
    </header>

    <!-- Progress Bar -->
    <div class="progress-container">
      <div id="progressBar" class="progress-bar" style="width: 0%"></div>
    </div>

    <!-- All Submissions Grid -->
    <div class="submissions-grid" id="submissionsGrid">
      <!-- Will be populated by JavaScript -->
    </div>

    <div class="chart-wrap card">
      <canvas id="votesChart" height="140"></canvas>
    </div>

    <div class="card summary">
      <div class="stat">
        <div class="small muted">Current Leader</div>
        <div id="leadText" style="font-weight:700;font-size:16px">—</div>
      </div>
      <div class="stat">
        <div class="small muted">Total Δ (this session)</div>
        <div id="sessionDelta" style="font-weight:700;font-size:16px">Loading...</div>
      </div>
      <div class="stat">
        <div class="small muted">Last update</div>
        <div id="lastUpdate" style="font-weight:700;font-size:14px">—</div>
      </div>
      <div class="stat">
        <div class="small muted">Fetch Speed</div>
        <div id="fetchSpeed" style="font-weight:700;font-size:14px">—</div>
      </div>
    </div>

    <div style="margin-top:12px" class="card">
      <div class="small muted">Console log</div>
      <div id="console" class="log"></div>
    </div>

    <footer>
      <div class="small muted">Using parallel fetching with 4 concurrent requests for maximum speed.</div>
    </footer>
  </div>

  <!-- Chart.js CDN -->
  <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
  <script>
  (function(){
    // CONFIG - Back to faster interval
    const INTERVAL_MS = 2500; // 2.5s
    const CONCURRENT_REQUESTS = 4; // Number of parallel requests
    
    // All 8 submissions
    const SUBMISSIONS = [
      { id: "24087", name: "xxknjt" },
      { id: "24084", name: "ini boo" },
      { id: "24081", name: "JustDani" },
      { id: "24078", name: "SonMV" },
      { id: "24075", name: "KekeLawar" },
      { id: "24072", name: "Yaraayay" },
      { id: "24069", name: "Wasawho" },
      { id: "24066", name: "searchforemma" }
    ];
    
    // Single pre-flight URL
    const PREFLIGHT_URL = "https://motionimefest.id/contest/newcomer-streamer-of-the-year/submissions/?cid=23816&cm=1&sd=desc&sb=date&cpn=1";
    
    const URL_TEMPLATE = (id) => `https://motionimefest.id/contest/newcomer-streamer-of-the-year/submission/${id}/?cid=23816&cm=1`;

    // Enhanced CORS proxies list
    const PROXY_LIST = [
      url => `https://api.allorigins.win/raw?url=${encodeURIComponent(url)}`,
      url => `https://corsproxy.io/?${encodeURIComponent(url)}`,
      url => `https://thingproxy.freeboard.io/fetch/${url}`,
      url => `https://api.codetabs.com/v1/proxy?quest=${encodeURIComponent(url)}`
    ];

    // DOM
    const statusEl = document.getElementById('status');
    const logEl = document.getElementById('console');
    const submissionsGridEl = document.getElementById('submissionsGrid');
    const leadTextEl = document.getElementById('leadText');
    const sessionDeltaEl = document.getElementById('sessionDelta');
    const lastUpdateEl = document.getElementById('lastUpdate');
    const fetchSpeedEl = document.getElementById('fetchSpeed');
    const progressBarEl = document.getElementById('progressBar');

    // state
    let lastVotes = {};
    let lastTime = null;
    let sessionDelta = {};
    let historyLabels = [];
    let historyData = {};
    let activeSubmissions = 0;
    let fetchTimes = [];

    // Initialize state
    SUBMISSIONS.forEach(sub => {
      lastVotes[sub.id] = null;
      sessionDelta[sub.id] = 0;
      historyData[sub.id] = [];
    });

    // helper: log (console area)
    function clog(msg){
      const ts = new Date().toLocaleTimeString();
      logEl.innerText = `[${ts}] ${msg}\n` + logEl.innerText;
      // Keep log from getting too long
      if(logEl.innerText.split('\n').length > 50) {
        logEl.innerText = logEl.innerText.split('\n').slice(0, 40).join('\n');
      }
    }

    // helper: parse numbers like "3,768" or "90.123"
    function parseNumber(s){
      if(!s) return null;
      const clean = s.replace(/,/g, '');
      const digits = clean.replace(/[^\d]/g, '');
      return digits ? parseInt(digits,10) : null;
    }

    // Improved parsing function
    function extractVotesViews(html){
      try {
        const tmp = document.createElement('div');
        tmp.innerHTML = html;
        const text = tmp.textContent || tmp.innerText || '';
        
        // Multiple patterns to find votes
        const votePatterns = [
          /([\d,]+)\s*Votes?/i,
          /Votes?\s*([\d,]+)/i,
          /"votes?"\s*:\s*"([\d,]+)"/i,
          /vote_count["']?\s*:\s*["']?([\d,]+)/i
        ];
        
        // Multiple patterns to find views
        const viewPatterns = [
          /([\d,]+)\s*Views?/i,
          /Views?\s*([\d,]+)/i,
          /"views?"\s*:\s*"([\d,]+)"/i,
          /view_count["']?\s*:\s*["']?([\d,]+)/i
        ];
        
        let votes = null, views = null;
        
        // Try each vote pattern
        for(const pattern of votePatterns) {
          const match = text.match(pattern);
          if(match) {
            votes = parseNumber(match[1]);
            if(votes !== null) break;
          }
        }
        
        // Try each view pattern
        for(const pattern of viewPatterns) {
          const match = text.match(pattern);
          if(match) {
            views = parseNumber(match[1]);
            if(views !== null) break;
          }
        }
        
        return {votes, views};
      } catch(e) {
        clog(`Error parsing HTML: ${e.message}`);
        return {votes: null, views: null};
      }
    }

    // Enhanced fetch with better error handling and timeout
    async function fetchWithFallback(url, attempt = 0){
      const maxAttempts = 2;
      const timeoutMs = 8000; // 8 second timeout
      
      // Create timeout promise
      const timeoutPromise = new Promise((_, reject) => 
        setTimeout(() => reject(new Error('Timeout')), timeoutMs)
      );
      
      // Try direct first
      if(attempt === 0) {
        try {
          const fetchPromise = fetch(url, {
            method: 'GET',
            mode: 'cors',
            headers: {
              'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
              'Cache-Control': 'no-cache'
            },
            cache: 'no-cache'
          });
          
          const r = await Promise.race([fetchPromise, timeoutPromise]);
          
          if(r.ok){
            const txt = await r.text();
            if(txt.length > 100 && /Votes?|Views?|vote|view/i.test(txt)) {
              return {html: txt, usedProxy: false, success: true};
            }
          }
        } catch(e) {
          // Silently fail and try proxy
        }
      }
      
      // Try proxies with retry logic
      if(attempt < maxAttempts) {
        const proxyIndex = attempt % PROXY_LIST.length;
        const proxy = PROXY_LIST[proxyIndex];
        const proxyUrl = proxy(url);
        
        try {
          const fetchPromise = fetch(proxyUrl, {
            method: 'GET',
            headers: {
              'Accept': 'text/html,application/xhtml+xml,application/xml;q=0.9,*/*;q=0.8',
            }
          });
          
          const r = await Promise.race([fetchPromise, timeoutPromise]);
          
          if(r.ok){
            const txt = await r.text();
            if(txt.length > 100) {
              return {html: txt, usedProxy: true, success: true, proxyUrl};
            }
          }
        } catch(e) {
          // Try next attempt
        }
        
        return fetchWithFallback(url, attempt + 1);
      }
      
      throw new Error(`Failed to fetch after ${maxAttempts} attempts`);
    }

    // Parallel fetching with concurrency control
    async function fetchAllSubmissionsParallel() {
      const results = {};
      let completed = 0;
      const total = SUBMISSIONS.length;
      
      // Update progress bar
      progressBarEl.style.width = '0%';
      
      // Function to process a batch of submissions
      const processBatch = async (batch) => {
        const batchPromises = batch.map(async (sub) => {
          try {
            // Set loading state
            const cardEl = document.getElementById(`card-${sub.id}`);
            if(cardEl) cardEl.classList.add('loading');
            
            const result = await fetchWithFallback(URL_TEMPLATE(sub.id));
            const extracted = extractVotesViews(result.html);
            
            results[sub.id] = extracted;
            
            // Remove loading state
            if(cardEl) cardEl.classList.remove('loading');
            
            if(extracted.votes !== null) {
              clog(`✓ ${sub.name}: ${extracted.votes} votes`);
            } else {
              clog(`✗ ${sub.name}: No data found`);
            }
          } catch(e) {
            clog(`✗ ${sub.name}: ${e.message}`);
            results[sub.id] = {votes: null, views: null};
            
            // Remove loading state on error too
            const cardEl = document.getElementById(`card-${sub.id}`);
            if(cardEl) cardEl.classList.remove('loading');
          }
          
          // Update progress
          completed++;
          const progress = (completed / total) * 100;
          progressBarEl.style.width = `${progress}%`;
          
          // Update status
          statusEl.innerText = `Fetching... ${completed}/${total}`;
        });
        
        return Promise.allSettled(batchPromises);
      };
      
      // Split submissions into batches
      const batches = [];
      for(let i = 0; i < SUBMISSIONS.length; i += CONCURRENT_REQUESTS) {
        batches.push(SUBMISSIONS.slice(i, i + CONCURRENT_REQUESTS));
      }
      
      // Process batches sequentially but each batch in parallel
      for(const batch of batches) {
        await processBatch(batch);
      }
      
      return {results, successCount: Object.values(results).filter(r => r.votes !== null).length};
    }

    // Create submission cards
    function createSubmissionCards() {
      submissionsGridEl.innerHTML = '';
      SUBMISSIONS.forEach(sub => {
        const card = document.createElement('div');
        card.className = 'submission-card';
        card.id = `card-${sub.id}`;
        card.innerHTML = `
          <h3>${sub.name} — ${sub.id}</h3>
          <div class="submission-stats">
            <div>
              <div id="votes-${sub.id}" class="submission-votes">—</div>
              <div id="views-${sub.id}" class="small muted">— views</div>
            </div>
            <div class="submission-delta">
              <div class="small muted">Δ per 2.5s</div>
              <div id="delta-${sub.id}" class="small">—</div>
              <div class="small muted" style="margin-top:6px">Rate (v/s)</div>
              <div id="rate-${sub.id}" class="small">—</div>
            </div>
          </div>
        `;
        submissionsGridEl.appendChild(card);
      });
    }

    // UI update function
    function updateUI(data){
      let activeCount = 0;
      
      // Update individual submission cards
      SUBMISSIONS.forEach(sub => {
        const votesEl = document.getElementById(`votes-${sub.id}`);
        const viewsEl = document.getElementById(`views-${sub.id}`);
        const deltaEl = document.getElementById(`delta-${sub.id}`);
        const rateEl = document.getElementById(`rate-${sub.id}`);
        const cardEl = document.getElementById(`card-${sub.id}`);
        
        const subData = data[sub.id];
        if (subData && subData.votes !== null) {
          activeCount++;
          votesEl.innerText = subData.votes.toLocaleString();
          viewsEl.innerText = subData.views !== null ? (subData.views.toLocaleString() + ' views') : '— views';
          deltaEl.innerText = (subData.delta >= 0 ? '+' + subData.delta : subData.delta);
          deltaEl.className = subData.delta > 0 ? 'small delta-up' : (subData.delta < 0 ? 'small delta-down' : 'small');
          rateEl.innerText = subData.rate !== null ? subData.rate.toFixed(4) : '—';
          cardEl.style.opacity = '1';
        } else {
          votesEl.innerText = '—';
          viewsEl.innerText = '— views';
          deltaEl.innerText = '—';
          rateEl.innerText = '—';
          cardEl.style.opacity = '0.7';
        }
      });

      // Update active count
      activeSubmissions = activeCount;

      // Update session delta
      let sessionText = "";
      SUBMISSIONS.forEach(sub => {
        if (sessionDelta[sub.id] !== 0) {
          if (sessionText) sessionText += " | ";
          sessionText += `${sub.name}: ${sessionDelta[sub.id] > 0 ? '+' : ''}${sessionDelta[sub.id]}`;
        }
      });
      sessionDeltaEl.innerText = sessionText || "No changes yet";

      // Update leader
      const validData = SUBMISSIONS.filter(sub => 
        data[sub.id] && data[sub.id].votes !== null
      );
      
      if (validData.length > 0) {
        const leader = validData.reduce((prev, curr) => 
          data[prev.id].votes > data[curr.id].votes ? prev : curr
        );
        const leaderVotes = data[leader.id].votes;
        
        // Check for ties
        const tied = validData.filter(sub => 
          data[sub.id].votes === leaderVotes
        );
        
        if (tied.length > 1) {
          leadTextEl.innerHTML = `Tie: ${tied.map(t => t.name).join(', ')} with ${leaderVotes.toLocaleString()} votes`;
        } else {
          leadTextEl.innerHTML = `${leader.name} leading with <strong>${leaderVotes.toLocaleString()}</strong> votes`;
        }
      } else {
        leadTextEl.innerText = 'No data available';
      }

      lastUpdateEl.innerText = new Date().toLocaleTimeString();
    }

    // Chart.js setup
    const ctx = document.getElementById('votesChart').getContext('2d');
    
    // Generate colors for all submissions
    const colors = [
      '#6bc1ff', '#ff6b6b', '#6ee7b7', '#f59e0b', '#a78bfa', 
      '#f97316', '#10b981', '#8b5cf6'
    ];
    
    const chartDatasets = SUBMISSIONS.map((sub, index) => ({
      label: `${sub.name}`,
      data: historyData[sub.id],
      borderColor: colors[index % colors.length],
      backgroundColor: colors[index % colors.length] + '20',
      tension: 0.2,
      pointRadius: 2,
      borderWidth: 2,
      hidden: false
    }));
    
    const chart = new Chart(ctx, {
      type: 'line',
      data: {
        labels: historyLabels,
        datasets: chartDatasets
      },
      options: {
        animation: false,
        responsive: true,
        maintainAspectRatio: false,
        scales: {
          x: { 
            display: true, 
            title: { display: false },
            ticks: {
              maxTicksLimit: 8
            }
          },
          y: { 
            display: true, 
            beginAtZero: false, 
            title: { display: true, text: 'Votes' } 
          }
        },
        plugins: { 
          legend: { 
            display: true,
            labels: {
              boxWidth: 12,
              font: {
                size: 11
              }
            }
          } 
        }
      }
    });

    // main polling function
    async function pollOnce(){
      const startTime = performance.now();
      
      try {
        // Fetch all submissions in parallel with concurrency control
        const {results, successCount} = await fetchAllSubmissionsParallel();
        
        const now = Date.now();
        const data = {};
        
        // Process results
        SUBMISSIONS.forEach(sub => {
          const extracted = results[sub.id];
          
          // Compute deltas
          let delta = 0, rate = null;
          if(lastTime !== null && lastVotes[sub.id] !== null && extracted.votes !== null){
            const elapsedSec = (now - lastTime)/1000;
            delta = extracted.votes - lastVotes[sub.id];
            rate = delta/elapsedSec;
          }
          
          // Update session totals
          if(delta) sessionDelta[sub.id] += delta;
          
          // Store data
          data[sub.id] = {
            votes: extracted.votes,
            views: extracted.views,
            delta: delta,
            rate: rate
          };
          
          // Update last votes
          lastVotes[sub.id] = extracted.votes;
        });
        
        // Push history
        const label = new Date().toLocaleTimeString();
        historyLabels.push(label);
        
        SUBMISSIONS.forEach(sub => {
          historyData[sub.id].push(data[sub.id].votes ?? null);
        });
        
        // Keep history limited
        if(historyLabels.length > 50){ 
          historyLabels.shift(); 
          SUBMISSIONS.forEach(sub => {
            historyData[sub.id].shift();
          });
        }

        // Update chart
        chart.data.labels = historyLabels.slice();
        SUBMISSIONS.forEach((sub, index) => {
          chart.data.datasets[index].data = historyData[sub.id].slice();
        });
        chart.update('none');

        // Update UI elements
        updateUI(data);

        // Update last time
        lastTime = now;

        const elapsedMs = Math.round(performance.now() - startTime);
        
        // Track fetch times for average calculation
        fetchTimes.push(elapsedMs);
        if(fetchTimes.length > 5) fetchTimes.shift();
        const avgFetchTime = fetchTimes.reduce((a, b) => a + b, 0) / fetchTimes.length;
        
        statusEl.innerText = `OK - ${successCount}/8 submissions - ${elapsedMs}ms`;
        fetchSpeedEl.textContent = `${elapsedMs}ms (avg: ${Math.round(avgFetchTime)}ms)`;
        
        clog(`Completed in ${elapsedMs}ms - ${successCount}/8 successful`);
        
      } catch(err) {
        statusEl.innerText = 'Error: ' + err.message;
        clog('Error in poll: ' + err.message);
      }
    }

    // start interval
    (async function startLoop(){
      // Create submission cards first
      createSubmissionCards();
      clog("Vote Comparator started - parallel fetching with 4 concurrent requests");
      
      // first poll immediately
      await pollOnce();
      setInterval(pollOnce, INTERVAL_MS);
    })();

  })();
  </script>
</body>
</html>
